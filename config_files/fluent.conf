<label @FLUENT_LOG>
<match fluent.*>
@type null
</match>
</label>

<source>
@type sql

host "#{ENV['PG_HOST']}"
port "#{ENV['PG_PORT']}"
database "#{ENV['PG_DB']}"
adapter postgresql
username "#{ENV['PG_USER']}"
password "#{ENV['PG_PASSWORD']}"

select_interval 60s  # optional
select_limit 20000     # optional
state_file /var/run/fluentd/sql_state

<table>
table pg_stat_statements
update_column calls
</table>

</source>
# Expose metrics in port 5001
<source>
@type prometheus
bind 0.0.0.0
port 5001
metrics_path /metrics
</source>

<source>
@type prometheus_output_monitor
interval 10
</source>

<match **>
@type logzio_buffered
endpoint_url "#{ENV['LOGZIO_LOG_LISTENER']}?token=#{ENV['LOGZIO_LOG_TOKEN']}&type=#{ENV['LOGZIO_TYPE']}"
output_include_time true
slow_flush_log_threshold "#{ENV['SLOW_FLUSH_LOG_THRESHOLD']}"
output_include_tags true
http_idle_timeout 10
<buffer>
# Set the buffer type to file to improve the reliability and reduce the memory consumption
@type "#{ENV['BUFFER_TYPE']}"


path "#{ENV['BUFFER_PATH']}"
# Set queue_full action to block because we want to pause gracefully
# in case of the off-the-limits load instead of throwing an exception
overflow_action "#{ENV['OVERFLOW_ACTION']}"
# Set the chunk limit conservatively to avoid exceeding the GCL limit
# of 10MiB per write request.
chunk_limit_size "#{ENV['CHUNK_LIMIT_SIZE']}"
# Cap the combined memory usage of this buffer and the one below to
# 2MiB/chunk * (6 + 2) chunks = 16 MiB
queue_limit_length "#{ENV['QUEUE_LIMIT_LENGTH']}"
# Never wait more than 5 seconds before flushing logs in the non-error case.
flush_interval "#{ENV['FLUSH_INTERVAL']}"
# Never wait longer than 30 seconds between retries.
retry_max_interval "#{ENV['RETRY_MAX_INTERVAL']}"
# Disable the limit on the number of retries (retry forever).
retry_forever "#{ENV['RETRY_FOREVER']}"
# Use multiple threads for processing.
flush_thread_count "#{ENV['FLUSH_THREAD_COUNT']}"
</buffer>
</match>


